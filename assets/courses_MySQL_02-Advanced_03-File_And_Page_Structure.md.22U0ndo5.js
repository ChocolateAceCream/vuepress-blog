import{_ as p}from"./chunks/ArticleMetadata.B9rxZela.js";import{_ as c,m as s,a as g,e as o,x as t,u as n,B as u,ah as m,o as r,p as k,q as y}from"./chunks/framework.BuAcqOzq.js";import"./chunks/theme.bbobKDr2.js";const _="/vuepress-blog/assets/page_structure.2YEgH_-8.png",f="/vuepress-blog/assets/record_structure.CoziMnVG.png",A="/vuepress-blog/assets/infimum_and_supremum.9NcioRgx.png",x="/vuepress-blog/assets/page_directory.YEvtJnJ9.png",w="/vuepress-blog/assets/B_TREE.B7nYHQe4.png",b="/vuepress-blog/assets/secondary_index.9E4AAwKV.png",E="/vuepress-blog/assets/FILE_PAGE_PREV_AND_FILE_PAGE_NEXT.CldPFE4p.png",V=JSON.parse('{"title":"File And Page Basics","description":"","frontmatter":{"title":"File And Page Basics","author":"ChocolateAceCream","date":"2024/02/18 10:24","isTop":true,"categories":["MySQL"],"tags":["MySQL"]},"headers":[],"relativePath":"courses/MySQL/02-Advanced/03-File_And_Page_Structure.md","filePath":"courses/MySQL/02-Advanced/03-File_And_Page_Structure.md","lastUpdated":1714762338000}'),F={name:"courses/MySQL/02-Advanced/03-File_And_Page_Structure.md"},B={id:"file-and-page",tabindex:"-1"},P=o("a",{class:"header-anchor",href:"#file-and-page","aria-label":'Permalink to "File And Page <Badge text="MySQL" type="warning" />"'},"​",-1),D=m('<h3 id="page" tabindex="-1">page <a class="header-anchor" href="#page" aria-label="Permalink to &quot;page&quot;">​</a></h3><p><img src="'+_+'" alt="page_structure"></p><p>User records is where innodb used to store data <img src="'+f+'" alt="record_structure"></p><ul><li><p>delete_mask when data get delete in page, it obtained a delete_mask and its address and space is record in a garbage linked list where their space are declared reusable.</p></li><li><p>infimum &amp; supremum the record next to infimum record is the min record stored in page and the max record&#39;s next is supremum <img src="'+A+'" alt="infimum_and_supremum"></p></li></ul><h5 id="page-directory" tabindex="-1">page directory <a class="header-anchor" href="#page-directory" aria-label="Permalink to &quot;page directory&quot;">​</a></h5><p>like a book directory. In order to improve the search efficiency, a page will divided records into several slots based on the following rules. so each time when look up a record, we can use binary search instead.</p><p>Constrains:</p><ol><li>infimum has its own slot</li><li>the slot contains supremum should have 1~8 records</li><li>other slot contains records count from 4~8</li></ol><p>Rules:</p><ol><li>initially create two slot, which contains infimum and supremum separately</li><li>when insert new record nr, find the slot which has a primary key value that bigger than nr&#39;s primary key and diff of those two key are minimum, until the member of this slot reached 8</li><li>when a slot already has 8 members and a new record is come into that slot, we divided this slot into 2 slots, one has 4 records and other has 5.</li></ol><h5 id="page-splitting" tabindex="-1">page splitting <a class="header-anchor" href="#page-splitting" aria-label="Permalink to &quot;page splitting&quot;">​</a></h5><p>when a page is full and a new record is coming, a new page is created and formed a two-way linked list with prev page. Since one constrain of page is that new page&#39;s primary key should be bigger than old page&#39;s. so the new record may need to be swapped with record from old page. <em><strong>p.s.</strong></em> page number may not be consecutive. e.g. page 3 may linked to page 28.</p><h5 id="page-directory-entry" tabindex="-1">page directory entry <a class="header-anchor" href="#page-directory-entry" aria-label="Permalink to &quot;page directory entry&quot;">​</a></h5><p>a page that isolated from other pages, with record_type = 1, used to store info of all other pages. It only contains two columns: page_no and min_primary_key in that page. So when searching, we can use the info in this page directory to apply dichotomy search.</p><p><img src="'+x+'" alt="page_directory"></p><h5 id="page-directory-tree-b-tree" tabindex="-1">page directory tree(B+ tree) <a class="header-anchor" href="#page-directory-tree-b-tree" aria-label="Permalink to &quot;page directory tree(B+ tree)&quot;">​</a></h5><p>when more page directory is required when pages increased, we can use B+ tree to store the relation between each page directories. <img src="'+w+'" alt="B+TREE"> As shown in the graph, actual records are stored at leaf nodes of the tree, which is referred as layer 0. So this graph&#39;s tree has two layers.</p><p><em><strong>Constrains:</strong></em></p><ul><li>if tree only has 1 layer, it can only has 1 leaf node which contain 100 data records.</li><li>each additional layer add 1000 times more leaf nodes, each contain 100 data records.</li></ul><p>so a 4 layer tree can contain 1000×1000×1000×100=100000000000 (10^11) rows of user data records, which is more than enough to use.</p><h5 id="secondary-index-another-b-tree" tabindex="-1">Secondary index (another B+ tree) <a class="header-anchor" href="#secondary-index-another-b-tree" aria-label="Permalink to &quot;Secondary index (another B+ tree)&quot;">​</a></h5><p>Default index is created by primary key. When the column is not indexed, we can create a secondary index to help us search faster. <img src="'+b+`" alt="secondary_index"></p><p>As noticed in the graph, the leaf nodes is no more storing user data. Instead, it stored the relation between primary key and the secondary indexed column.</p><p>So when we look up a user record using secondary index, we first find its primary key using that new B+tree, then we use the primary key to look up for the actual user data in the default B+ tree.</p><h4 id="union-index-special-secondary-index" tabindex="-1">Union index (special secondary index) <a class="header-anchor" href="#union-index-special-secondary-index" aria-label="Permalink to &quot;Union index (special secondary index)&quot;">​</a></h4><p>we can use two column together as a union index, e.g. c2 and c3. The rule is that we first compare each record using c2, if equal, then compare using c3. The other difference is that the leaf nodes now will store the primary key, c2 and c3 value.</p><p>The mechanism is same for normal single columned secondary index, which first compare the column value then compare the primary key value.</p><h4 id="b-tree-root-node" tabindex="-1">B+ tree root node <a class="header-anchor" href="#b-tree-root-node" aria-label="Permalink to &quot;B+ tree root node&quot;">​</a></h4><p>when a table is created, a B+ tree root node is created at the same time. When inserting new data into table, we first fill up the root node. When it&#39;s full, we first copy the root node data into new page and doing page splitting, then upgrade root node to a page directory to store the info of the split pages.</p><h4 id="index-operations" tabindex="-1">Index operations <a class="header-anchor" href="#index-operations" aria-label="Permalink to &quot;Index operations&quot;">​</a></h4><ol><li>add index</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">alter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> idx_xxx1_xxx2(xxx1,xxx2)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">-- xxx1 and xxx2 are the columns that need to be indexed</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">-- or, you can add index when create table</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> index_demo</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	c1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">INT</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	c2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">INT</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	c3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">CHAR</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ( </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ),</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ( c1 ),</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">INDEX</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> idx_c2_c3 ( c2, c3 ));</span></span></code></pre></div><ol start="2"><li>delete index</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">alter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">drop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> idx_xxx</span></span></code></pre></div><h3 id="file" tabindex="-1">FILE <a class="header-anchor" href="#file" aria-label="Permalink to &quot;FILE&quot;">​</a></h3><h5 id="fil-page-prev-fil-page-next" tabindex="-1">FIL_PAGE_PREV &amp; FIL_PAGE_NEXT <a class="header-anchor" href="#fil-page-prev-fil-page-next" aria-label="Permalink to &quot;FIL_PAGE_PREV &amp; FIL_PAGE_NEXT&quot;">​</a></h5><p>when a table contains millions of records, InnoDB will store them in several pages and use FIL_PAGE_PREV &amp; FIL_PAGE_NEXT to form a two-way linked list between pages.</p><p><img src="`+E+'" alt="FILE_PAGE_PREV_AND_FILE_PAGE_NEXT"></p><h5 id="file-trailer" tabindex="-1">File Trailer <a class="header-anchor" href="#file-trailer" aria-label="Permalink to &quot;File Trailer&quot;">​</a></h5><p>when record is modified in memory, when sync the change to the storage, we first calculate checksum and write it to File Header, then after sync is done, we calculate checksum again and write it to File Trailer. Then we compare these two checksum, if not equal, means something wrong in the process.</p>',40);function v(e,C,q,T,I,S){const l=s("Badge"),d=p,h=s("ClientOnly");return r(),g("div",null,[o("h1",B,[t("File And Page "),n(l,{text:"MySQL",type:"warning"}),t(),P]),n(h,null,{default:u(()=>{var a,i;return[(((a=e.$frontmatter)==null?void 0:a.aside)??!0)&&(((i=e.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(r(),k(d,{key:0,article:e.$frontmatter},null,8,["article"])):y("",!0)]}),_:1}),D])}const G=c(F,[["render",v]]);export{V as __pageData,G as default};
