import{_ as d}from"./chunks/ArticleMetadata.j3Ov-vUj.js";import{_ as c,m as a,a as k,e as o,x as s,u as n,B as u,ah as m,o as l,p as y,q as b}from"./chunks/framework.BuAcqOzq.js";import"./chunks/theme.D7QXwtHB.js";const P=JSON.parse('{"title":"Interview Preps","description":"","frontmatter":{"title":"Interview Preps","author":"ChocolateAceCream","date":"2025/03/27 19:00","isTop":false,"categories":["backend"],"tags":["Go","Interview","Database"]},"headers":[],"relativePath":"categories/backend/2025/03/27/dairy.md","filePath":"categories/backend/2025/03/27/dairy.md","lastUpdated":1743376741000}'),g={name:"categories/backend/2025/03/27/dairy.md"},f={id:"interview-preps",tabindex:"-1"},w=o("a",{class:"header-anchor",href:"#interview-preps","aria-label":'Permalink to "Interview Preps  <Badge text="Go" type="warning" />"'},"​",-1),A=m(`<p>Today I did some prep works for the upcoming interviews, reviewed some concepts/algorithms/designs. Just want to write it down so my brain can turn them into long-term memories while I sleeping tonight.</p><h2 id="difference-between-primary-key-and-index" tabindex="-1">Difference between Primary key and Index <a class="header-anchor" href="#difference-between-primary-key-and-index" aria-label="Permalink to &quot;Difference between Primary key and Index&quot;">​</a></h2><ul><li>The main difference is that a indexed field can contains duplicated values (unless it&#39;s unique index), while primary key is always unique. So, you cannot always reference a foreign key on index (unless it&#39;s unique)</li><li>Primary key can be composite, same as index.</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> TABLE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> posts</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    topic_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    post_seq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> AUTO_INCREMENT,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">-- Sequence within topic</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    user_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">INT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> NOT NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    post_date </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">DATETIME</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    content </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">TEXT</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (topic_id, post_seq),  </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">-- Natural composite key</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (user_id)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">-- For user-centric queries</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> INDEX</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> index_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> ON</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> table_name (col1, col2, ...);</span></span></code></pre></div><h2 id="bloom-filter" tabindex="-1">bloom filter <a class="header-anchor" href="#bloom-filter" aria-label="Permalink to &quot;bloom filter&quot;">​</a></h2><p>This topic with a separated single blog, but I just want to summarize several key points about bloom filter.</p><h3 id="why" tabindex="-1">why? <a class="header-anchor" href="#why" aria-label="Permalink to &quot;why?&quot;">​</a></h3><p>if you have 1MB memory and 10M items, you want to check the next new item is shown before, then you can use bloom filter to quickly find out. But, there might be a small chance of false negative (means it detect item has shown before but it actually not) while no false positive(it detect item has not shown before then it must have not shown before)</p><h3 id="how" tabindex="-1">How? <a class="header-anchor" href="#how" aria-label="Permalink to &quot;How?&quot;">​</a></h3><p>Use several hash functions to hash the item id, then % 8,388,608 (1MB * 8 = bits) to fit in []byte, check that byte to true. When look up, do the same, if any position returned by hash function in []byte found false, then 100% item not shown before. However, if all position returned true, it still have chance of actually not shown.</p><h3 id="standard-capacity-formula" tabindex="-1">Standard Capacity Formula: <a class="header-anchor" href="#standard-capacity-formula" aria-label="Permalink to &quot;Standard Capacity Formula:&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span>n = - (m * ln(p)) / (ln(2))²</span></span></code></pre></div><p>Where:</p><ul><li>m = 8,388,608 bits</li><li>p = desired false positive probability</li><li>n = maximum number of items</li></ul><h4 id="practical-examples" tabindex="-1">Practical Examples: <a class="header-anchor" href="#practical-examples" aria-label="Permalink to &quot;Practical Examples:&quot;">​</a></h4><table><thead><tr><th>False Positive Rate (p)</th><th>Max Items (n)</th><th>Hash Functions (k)</th></tr></thead><tbody><tr><td>1% (0.01)</td><td>~1,209,513</td><td>5</td></tr><tr><td>0.1% (0.001)</td><td>~806,342</td><td>7</td></tr><tr><td>0.01% (0.0001)</td><td>~604,757</td><td>10</td></tr></tbody></table><h2 id="http-code-302-307" tabindex="-1">Http code 302 &amp; 307 <a class="header-anchor" href="#http-code-302-307" aria-label="Permalink to &quot;Http code 302 &amp; 307&quot;">​</a></h2><p>both means redirect request, so once response return by backend, frontend will redirect to that url. However, 302 will convert post to get but 307 will keep the original request</p><h2 id="consistent-hashing" tabindex="-1">Consistent Hashing <a class="header-anchor" href="#consistent-hashing" aria-label="Permalink to &quot;Consistent Hashing&quot;">​</a></h2><p>similar to bloom filter, you hash the tag, then find the right place to put it in. Image we use hash as a circle. then we use hash function to hash the tag, find next v-node on the ring</p><h2 id="time-wheel" tabindex="-1">Time wheel <a class="header-anchor" href="#time-wheel" aria-label="Permalink to &quot;Time wheel&quot;">​</a></h2><p>like cron job, but more efficient. It should contains following elements</p><ol><li>step interval</li><li>a slot[] to store jobs&#39; ID that should run at certain time</li><li>a mapper to find job&#39;s execute function with given id</li><li>a lock</li><li>a pointer to store current slot index.</li></ol><p>for jobs that to be put into slot, it should contains</p><ol><li>id</li><li>cycle number</li></ol><p>Process:</p><ol><li>calculate the slot index using the job&#39;s scheduled time, total numbers of slots, and step interval of time wheel. Also calculate the cycle number.</li><li>each time interval, time wheel moved one slot up, until reach the end of slot, then start from beginning. When a slot is hit, iterate the store jobs from that slot&#39;s ID list, check cycle number, if it&#39;s 0, means should execute job now. if not, reduce cycle number by 1.</li></ol>`,27);function _(e,D,v,C,x,E){const h=a("Badge"),r=d,p=a("ClientOnly");return l(),k("div",null,[o("h1",f,[s("Interview Preps "),n(h,{text:"Go",type:"warning"}),s(),w]),n(p,null,{default:u(()=>{var t,i;return[(((t=e.$frontmatter)==null?void 0:t.aside)??!0)&&(((i=e.$frontmatter)==null?void 0:i.showArticleMetadata)??!0)?(l(),y(r,{key:0,article:e.$frontmatter},null,8,["article"])):b("",!0)]}),_:1}),A])}const F=c(g,[["render",_]]);export{P as __pageData,F as default};
