import{_ as r}from"./chunks/ArticleMetadata.BXy0hzJo.js";import{_ as k,m as a,a as c,e as h,x as e,u as n,B as g,ah as y,o as l,p as u,q as m}from"./chunks/framework.BuAcqOzq.js";import"./chunks/theme.B6kSHkMK.js";const N=JSON.parse('{"title":"Operation Cost","description":"","frontmatter":{"title":"Operation Cost","author":"ChocolateAceCream","date":"2024/02/12 10:24","isTop":true,"categories":["MySQL"],"tags":["MySQL"]},"headers":[],"relativePath":"courses/MySQL/01-Basic/01-cost.md","filePath":"courses/MySQL/01-Basic/01-cost.md","lastUpdated":1714678151000}'),A={name:"courses/MySQL/01-Basic/01-cost.md"},C={id:"cost-of-mysql-operations",tabindex:"-1"},F=h("a",{class:"header-anchor",href:"#cost-of-mysql-operations","aria-label":'Permalink to "Cost of mysql operations <Badge text="MySQL" type="warning" />"'},"​",-1),b=y(`<p>The total cost is I/O + CPU</p><h5 id="i-o-cost" tabindex="-1">I/O cost: <a class="header-anchor" href="#i-o-cost" aria-label="Permalink to &quot;I/O cost:&quot;">​</a></h5><p>the cost to load data from disk to memory</p><p>default <em><strong>I/O cost for loading a page is 1</strong></em></p><h5 id="cpu-cost" tabindex="-1">CPU cost: <a class="header-anchor" href="#cpu-cost" aria-label="Permalink to &quot;CPU cost:&quot;">​</a></h5><p>read and search cost.</p><p>default <em><strong>CPU cost for read a piece of data and perform operations on it is 0.2</strong></em></p><p><em><strong>ps</strong></em> 1 and 0.2 are called const of cost.</p><h3 id="example-a-optimize-process-of-query-execution" tabindex="-1">example: a optimize process of query execution <a class="header-anchor" href="#example-a-optimize-process-of-query-execution" aria-label="Permalink to &quot;example: a optimize process of query execution&quot;">​</a></h3><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SELECT</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	*</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">FROM</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	single_table</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">	key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">IN</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> ( </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;c&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key_part1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">LIKE</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;%hello%&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">	AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> common_field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;123&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span></code></pre></div><ol><li>get an idea of table</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">show </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> status</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> like</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;single_table&#39;</span></span></code></pre></div><ul><li><p>rows: if using InnoDB, the number returned are estimation. if using MyISAM, then the number returned are accurate.</p></li><li><p>Data_length: the table file size in disk ( in B) Data_length = count of clustered index pages * page size</p></li></ul><p>the default page size is 16kb, which is 16 * 1024, then count of pages = Data_length / (16 * 1024)</p><p>in this case, the count of pages is about 161.</p><p>I/O cost is: 161 * 1 = 161 (might be slight difference since mysql designer did minor adjust in code)</p><p>CPU cost is: rows * 0.2 = 18525 * 0.2 = 3705</p><p>the total cost for whole table scan is 161 + 3705 = 3866</p><ol start="2"><li>calculate the cost when using index</li></ol><blockquote><p>AND key2 &gt; 10 AND key2 &lt; 1000</p></blockquote><p>mysql designer assume for the cost for reading the index key range from a to b is equal to the cost of reading a page, which is 1. so the I/O cost is 1</p><p>and totally there are <em><strong>485</strong></em> counts of record for key2 fall in the range 10 ~ 1000, and the CPU cost for reading 485 records are: 485 * 0.2 = 97</p><p>and total cost for reading index is 1 + 97 = 98</p><p>then we need to do index lookup in original table for each of 485 records:</p><p>mysql designer assume the cost for each index lookup equals to the cost of loading a page, which is 1 so the I/O cost for index lookup for total 485 records is: 485 * 1 = 485 and the CPU cost is 485 * 0.2 = 97</p><p>so the total cost for index lookup is 485 + 97 = 582 plus the previous cost for reading index 98, the final cost for using key2 as index would be 582 + 98 = 680</p><ol start="3"><li>repeat above process for each sub-query</li></ol><blockquote><p>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</p></blockquote><p>this sub-query is equal to: key1 in</p><ul><li>[&#39;a&#39;, &#39;a&#39;] 40 records</li><li>[&#39;b&#39;, &#39;b&#39;] 50 records</li><li>[&#39;c&#39;, &#39;c&#39;] 30 records (total 30 + 40 + 50 = 120)</li></ul><p>so the total cost for using key1 as index is: 3 + 120 + 120<em>0.2+ 120</em>0.2 = 171</p><ol start="4"><li>Compare the cost for each index approach for the remaining query that cannot apply index lookup approach:</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key2 # since </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">not</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> compare </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> const, cannot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">use</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> index</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key_part1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">LIKE</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;%hello%&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> # </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">start</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> with</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> %, cannot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">use</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> index</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AND</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> common_field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;123&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; # common_field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">is</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> indexed.</span></span></code></pre></div><p>since we will have to use whole table scan approach, so we can omit them compare cost of which index we using.</p><p>so now we can either using key1 or key2 as index for searching. since key2 cost is 680 and key1 cost is 171, so we choose key1 as index to use</p><p><em><strong>p.s.</strong></em> if there exist index intersection, we can further reduce the cost by applying index merging.</p><h4 id="index-dive" tabindex="-1">index dive <a class="header-anchor" href="#index-dive" aria-label="Permalink to &quot;index dive&quot;">​</a></h4><p>for sub-query</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> single_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">IN</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;aa1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;aa2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;aa3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, ... , </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;zzz&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>since key1 in not a unique index, for each IN condition &#39;aa1&#39;, &#39;aa2&#39;, ..., there might exist multiple records matched the condition. so we lookup the B+ tree to determine the range of those records, and that approach is called <em><strong>index dive</strong></em>.</p><p>for some special case: 2000+ params inside IN condition, we use the const eq_range_index_dive_limit to decide if we using this approach</p><ul><li>check the value of eq_range_index_dive_limit:</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">show variables </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">like</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;%dive%&#39;</span></span></code></pre></div><p>eq_range_index_dive_limit 200</p><h4 id="join-table-search-cose" tabindex="-1">Join Table Search Cose <a class="header-anchor" href="#join-table-search-cose" aria-label="Permalink to &quot;Join Table Search Cose&quot;">​</a></h4><p>Total cost = cost of visiting driving table + fanout record counts * cost of visiting driven table. e.g.</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> single_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">INNER JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> single_table2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> s1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> AND</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> s1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span></code></pre></div><p>this sql first use index to find records which has key2 in (10, 1000). And the result is called fanout. Then for each record in fanout, it will lookup according record in table 2.</p><p>For outer join (e.g. left or right join), the driving table and driven table are fixed, so the cost would be fixed either. However, for inner join, we need to calculate the cost of using each table as driving table and choose the smaller cost one.</p><p>e.g.</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> single_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">INNER JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> single_table2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> s1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> s2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">common_field</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> s1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AND</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">s1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AND</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">s2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1000</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">AND</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">s2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 2000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span></code></pre></div><p>now we need to compare cost of using table 1 as driving table and using table 2 as driving table and choose the smaller one.</p><p>And the main difference is usually the fanout * cost of visiting driven table part. so we need always try to minimum fanout counts and cost of visiting driven table. so, better create index in driven table and use that index as join key.</p><h4 id="more-than-2-tables-join" tabindex="-1">More than 2 tables join <a class="header-anchor" href="#more-than-2-tables-join" aria-label="Permalink to &quot;More than 2 tables join&quot;">​</a></h4><p>if we need to join more than 2 tables, the case we need to evaluate are n!. e.g. join A and B and C: we can arrange ABC or ACB or BAC or BCA or CAB or CBA, totally is 3<em>2</em>1 = n! = 6 cases. Since there are too many cases to be evaluated, we keep an variable to store minimum cost. Once in the middle of calculating cost for one case is exceeding the minimum cost, the evaluation process is terminated.</p><p>That variable is called <em><strong>optimizer_search_depth</strong></em>.</p><p>Also, mysql designer suggested some experience based rules and any cases meet the rules will not be considered.</p><p>A system variable called <em><strong>optimizer_prune_level</strong></em> is used to control whether the rules are on or off</p><h4 id="const-in-calculating-cost" tabindex="-1">const in calculating cost <a class="header-anchor" href="#const-in-calculating-cost" aria-label="Permalink to &quot;const in calculating cost&quot;">​</a></h4><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">SHOW </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">TABLE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> mysql </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">LIKE</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;%cost%&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span></code></pre></div><table><thead><tr><th>Tables_in_mysql (%cost%)</th></tr></thead><tbody><tr><td>engine_cost</td></tr><tr><td>server_cost</td></tr></tbody></table><p>Server_cost table stores cost for server layer, such as join, search, syntax analyzer, and optimizer etc. engine_cost table, on the other hand, is used to store cost for data I/O</p><p>Now dig deeper in server_cost table</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> from</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> mysql</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">server_cost</span></span></code></pre></div><table><thead><tr><th>cost_name</th><th>cost_value</th><th>last_update</th><th>comment</th></tr></thead><tbody><tr><td>disk_temptable_create_cost</td><td>NULL</td><td>2018-01-20 12:03:21</td><td>NULL</td></tr><tr><td>disk_temptable_row_cost</td><td>NULL</td><td>2018-01-20 12:03:21</td><td>NULL</td></tr><tr><td>key_compare_cost</td><td>NULL</td><td>2018-01-20 12:03:21</td><td>NULL</td></tr><tr><td>memory_temptable_create_cost</td><td>NULL</td><td>2018-01-20 12:03:21</td><td>NULL</td></tr><tr><td>memory_temptable_row_cost</td><td>NULL</td><td>2018-01-20 12:03:21</td><td>NULL</td></tr><tr><td>row_evaluate_cost</td><td>NULL</td><td>2018-01-20 12:03:21</td><td>NULL</td></tr></tbody></table><p>cost_value is NULL for all const by default, which means default value will be used to each const</p><table><thead><tr><th>name</th><th>default value</th><th>comment</th></tr></thead><tbody><tr><td>disk_temptable_create_cost</td><td>40.0</td><td>创建基于磁盘的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td>disk_temptable_row_cost</td><td>1.0</td><td>向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。</td></tr><tr><td>key_compare_cost</td><td>0.1</td><td>两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升filesort的成本，让优化器可能更倾向于使用索引完成排序而不是filesort。</td></tr><tr><td>memory_temptable_create_cost</td><td>2.0</td><td>创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td>memory_temptable_row_cost</td><td>0.2</td><td>向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。</td></tr><tr><td>row_evaluate_cost</td><td>0.2</td><td>这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。</td></tr></tbody></table><p>P.S. When mysql execute query that includes DISTINCT, GROUP_BY, UNION, and SORTING, mysql might create a temp table to help searching. When records count are huge, that temp table might be created using MyISAM or InnoDB as engine to use disk as storage. And when the count of records are low, might use Memory engine to create memory based table. e.g. For Distinct search, mysql can create a temp table with unique index and insert records in this temp table, once all records inserted, that temp table is the result set.</p><p>For engine_cost const:</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> from</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> mysql</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">engine_cost</span></span></code></pre></div><table><thead><tr><th>engine_name</th><th>device_type</th><th>cost_name</th><th>cost_value</th><th>last_update</th><th>comment</th><th>default_value</th></tr></thead><tbody><tr><td>default</td><td>0</td><td>io_block_read_cost</td><td>NULL</td><td>2023-02-16 17:58:00</td><td>NULL</td><td>1</td></tr><tr><td>default</td><td>0</td><td>memory_block_read_cost</td><td>NULL</td><td>2023-02-16 17:58:00</td><td>NULL</td><td>0.25</td></tr></tbody></table><table><thead><tr><th>name</th><th>default value</th><th>comment</th></tr></thead><tbody><tr><td>io_block_read_cost</td><td>1.0</td><td>从磁盘上读取一个块对应的成本。请注意我使用的是块，而不是页这个词儿。对于InnoDB存储引擎来说，一个页就是一个块，不过对于MyISAM存储引擎来说，默认是以4096字节作为一个块的。增大这个值会加重I/O成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。</td></tr><tr><td>memory_block_read_cost</td><td>1.0</td><td>与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。</td></tr></tbody></table><p>The reason for using 1.0 for both const is because mysql cannot tell if a block is loaded into memory yet, so designer assume the cost is equal to load data from disk or memory.</p>`,73);function D(s,_,f,B,v,E){const p=a("Badge"),d=r,o=a("ClientOnly");return l(),c("div",null,[h("h1",C,[e("Cost of mysql operations "),n(p,{text:"MySQL",type:"warning"}),e(),F]),n(o,null,{default:g(()=>{var i,t;return[(((i=s.$frontmatter)==null?void 0:i.aside)??!0)&&(((t=s.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(l(),u(d,{key:0,article:s.$frontmatter},null,8,["article"])):m("",!0)]}),_:1}),b])}const L=k(A,[["render",D]]);export{N as __pageData,L as default};
