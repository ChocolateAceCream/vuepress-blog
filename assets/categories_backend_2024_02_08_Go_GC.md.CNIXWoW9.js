import{_ as h}from"./chunks/ArticleMetadata.BM8lr8hO.js";import{_ as p,m as a,a as d,e as s,x as n,u as r,B as u,ah as G,o as i,p as g,q as f}from"./chunks/framework.BuAcqOzq.js";import"./chunks/theme.ByOXXUmZ.js";const B=JSON.parse('{"title":"Go GC","description":"","frontmatter":{"title":"Go GC","author":"ChocolateAceCream","date":"2024/02/08 19:00","isTop":false,"categories":["backend"],"tags":["Go","GC"]},"headers":[],"relativePath":"categories/backend/2024/02/08/Go_GC.md","filePath":"categories/backend/2024/02/08/Go_GC.md","lastUpdated":1714705686000}'),y={name:"categories/backend/2024/02/08/Go_GC.md"},_={id:"go-gc",tabindex:"-1"},C=s("a",{class:"header-anchor",href:"#go-gc","aria-label":'Permalink to "Go GC <Badge text="Go" type="warning" />"'},"​",-1),w=G('<p>GO GC is basically repetition of three stage:</p><ul><li>sweeping: sweep off any memory from heap that is not marked as live, free them</li><li>turning off: sleep until next cycle</li><li>marking: scan whole heap, mark resource that is still using as live</li></ul><p>GO GC is a trade of memory usage and CPU cost. a more frequently GC cycle will free more memory but cost more CPU runtime.</p><h3 id="tunning-by-gogc" tabindex="-1">Tunning by GOGC <a class="header-anchor" href="#tunning-by-gogc" aria-label="Permalink to &quot;Tunning by GOGC&quot;">​</a></h3><p>GOGC = Target Heap Memory = Total heap memory Total Heap Memory = Live Heap + New heap memory(for GC) New heap memory = (Live heap + GC roots) * GOGC / 100 and minimum New heap memory is 4MB <em><strong>So doubling GOGC will double heap memory overheads and roughly halve GC CPU cost</strong></em></p><p>set GOGC=off can set GOGC value to infinity. However, the memory limit is defined to be soft, the Go runtime <em><strong>makes no guarantees</strong></em> that it will maintain this memory limit under all circumstances; it only promises <em><strong>some reasonable amount of effort</strong></em>. It allow a peak memory exceeding the limit for as long as 2 * GOMAXPROCS CPU-second. Means at worse case, <em><strong>only 50% of CPU runtime is spent on GC</strong></em> and other is spent on running program, so you program will slow down at most by 2x</p><p>However, even if GOGC=off, there&#39;s a GOMEMLIMIT environment variable which can be used to set the memory limit GOMEMLIMIT = heap + system. However, when GOMEMLIMIT is small, GC will keep blocking the process since it is required to clean up more memory for system to run, so be careful when setting GOMEMLIMIT</p><h3 id="best-practice" tabindex="-1">Best Practice <a class="header-anchor" href="#best-practice" aria-label="Permalink to &quot;Best Practice&quot;">​</a></h3><ol><li>run in container with a fixed amount of available memory, with an additional 5%~10% headroom.</li><li>Don&#39;t set GOGC to off when there&#39;s a an actual memory limit exists. It will slow the program 2x</li><li>When increase the input size, memory usage is increasing proportionally, don&#39;t set a memory limit on such case.</li></ol>',9);function b(e,O,M,k,v,T){const l=a("Badge"),m=h,c=a("ClientOnly");return i(),d("div",null,[s("h1",_,[n("Go GC "),r(l,{text:"Go",type:"warning"}),n(),C]),r(c,null,{default:u(()=>{var t,o;return[(((t=e.$frontmatter)==null?void 0:t.aside)??!0)&&(((o=e.$frontmatter)==null?void 0:o.showArticleMetadata)??!0)?(i(),g(m,{key:0,article:e.$frontmatter},null,8,["article"])):f("",!0)]}),_:1}),w])}const N=p(y,[["render",b]]);export{B as __pageData,N as default};
