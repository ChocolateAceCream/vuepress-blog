import{_ as d}from"./chunks/ArticleMetadata.DCa9ddbI.js";import{_ as k,m as a,a as c,e as o,x as t,u as n,B as u,ah as m,o as l,p as y,q as g}from"./chunks/framework.BuAcqOzq.js";import"./chunks/theme.CZtxdv8p.js";const S=JSON.parse('{"title":"Optimization with sql re-write","description":"","frontmatter":{"title":"Optimization with sql re-write","author":"ChocolateAceCream","date":"2024/02/20 10:24","isTop":true,"categories":["MySQL"],"tags":["MySQL"]},"headers":[],"relativePath":"courses/MySQL/02-Advanced/05-Optimization_with_SQL_rewrite.md","filePath":"courses/MySQL/02-Advanced/05-Optimization_with_SQL_rewrite.md","lastUpdated":1714762338000}'),b={name:"courses/MySQL/02-Advanced/05-Optimization_with_SQL_rewrite.md"},E={id:"how-mysql-do-the-optimization-using-sql-re-write",tabindex:"-1"},f=o("a",{class:"header-anchor",href:"#how-mysql-do-the-optimization-using-sql-re-write","aria-label":'Permalink to "How MySql Do the optimization using sql re-write <Badge text="MySQL" type="warning" />"'},"​",-1),A=m(`<h4 id="remove-useless-and" tabindex="-1">remove useless ( and ) <a class="header-anchor" href="#remove-useless-and" aria-label="Permalink to &quot;remove useless ( and )&quot;">​</a></h4><p>e.g. ((a = 5 and b = c) or (a&gt;c) and (c &lt;5)) can be optimized as: (a = 5 and b = c) or (a &gt; c) and (c &lt; 5)</p><h4 id="constant-propagation" tabindex="-1">constant_propagation <a class="header-anchor" href="#constant-propagation" aria-label="Permalink to &quot;constant_propagation&quot;">​</a></h4><p>a = 5 and b&gt;a will be translated into a = 5 and b &gt; 5</p><p>p.s. not to use constant_propagation in OR</p><h4 id="equality-propagation" tabindex="-1">equality_propagation <a class="header-anchor" href="#equality-propagation" aria-label="Permalink to &quot;equality_propagation&quot;">​</a></h4><p>a = b and b = c and c = 5 can be simplified as a = 5 and b = 5 and c = 5</p><h4 id="trivial-condition-removal" tabindex="-1">trivial_condition_removal <a class="header-anchor" href="#trivial-condition-removal" aria-label="Permalink to &quot;trivial_condition_removal&quot;">​</a></h4><p>for those forever true or false expression, the condition will be replaced with true or false e.g (a &lt; 1 and b = b) OR (a = 6 OR 5 != 5) result: a &lt; 1 or a = 6</p><h4 id="do-the-calculation-in-expression" tabindex="-1">do the calculation in expression <a class="header-anchor" href="#do-the-calculation-in-expression" aria-label="Permalink to &quot;do the calculation in expression&quot;">​</a></h4><p>e.g. a = 5 + 1 result: a = 6 p.s. column has to be shown as a isolated item in expression in order to perform the calculation e.g. -a &lt; 8 ABS(a) &gt; 5 won&#39;t be transformed</p><h4 id="haveing-and-where" tabindex="-1">HAVEING and WHERE <a class="header-anchor" href="#haveing-and-where" aria-label="Permalink to &quot;HAVEING and WHERE&quot;">​</a></h4><p>where is executed before group by and aggregation having is executed after group by and aggregation IF no group by is used, having behaves same as the where. so optimizer will combine where and having statement together</p><h4 id="inner-join-vs-outer-left-right-join" tabindex="-1">INNER JOIN vs OUTER/LEFT/RIGHT JOIN <a class="header-anchor" href="#inner-join-vs-outer-left-right-join" aria-label="Permalink to &quot;INNER JOIN vs  OUTER/LEFT/RIGHT JOIN&quot;">​</a></h4><p>driving table and driven table for inner join is exchangeable. if record from driving table cannot find a match in driven table, that record will be discased.</p><p>For outer join, if driving table&#39;s record cannot find in driven table, it still be added to the result set, only need to set NULL for the filed of each column of driven table for that record.</p><h4 id="reject-null" tabindex="-1">reject-NULL <a class="header-anchor" href="#reject-null" aria-label="Permalink to &quot;reject-NULL&quot;">​</a></h4><p>if where closure Implicitly indicate some non-null conditions for certain columns from driven table, then those OUTER/LEFT/RIGHT join can be simplified as a inner join. Optimizer will consider the cheapest way of join to execute. SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2; this sample query will be simplified as SELECT * FROM t1 inner join t2 on t1.ma = t2.m2 where t2.m2 = 2</p><h4 id="scalar-subquery-and-row-subquery" tabindex="-1">scalar subquery and row subquery <a class="header-anchor" href="#scalar-subquery-and-row-subquery" aria-label="Permalink to &quot;scalar subquery and row subquery&quot;">​</a></h4><p>both subquery return a single line of record or a single value. Usually used in bool express for comparison e.g</p><blockquote><p>select * from ts where m1 &lt; (select MIN(m2) from t2) or select * from t1 where (m1,n1) = (select m2, n2 from t2 limit 1)</p></blockquote><h4 id="not-in-any-some-all-subquery" tabindex="-1">[NOT]IN/ANY/SOME/ALL(subquery) <a class="header-anchor" href="#not-in-any-some-all-subquery" aria-label="Permalink to &quot;[NOT]IN/ANY/SOME/ALL(subquery)&quot;">​</a></h4><p>constrains:</p><ol><li>no <em><strong>limit</strong></em> keywords allowed in subquery</li><li>order by is not necessary</li><li>distinct is also unnecessary since returned value is a set</li><li>group by without aggregation/having is useless so optimizer will remove all these redundant syntax.</li></ol><ul><li>in(subquery):</li></ul><blockquote><p>select * from t1 where (m1, n1) in (select m2,n2 from t2)</p></blockquote><ul><li>ANY/SOME(subquery) are synonymous and can be used interchangeably:</li></ul><blockquote><p>select * from t1 where m1 &gt; ANY(select m2 from t2)</p></blockquote><ul><li><p>ALL(subquery) select * from t1 where m1 &gt; ALL(select m2 from t2)</p></li><li><p>EXISTS(subquery) return true if subquery returns any records. select * from t1 where exists(select 1 from t2)</p></li></ul><h4 id="in-subquery-optimization" tabindex="-1">in(subquery) optimization <a class="header-anchor" href="#in-subquery-optimization" aria-label="Permalink to &quot;in(subquery) optimization&quot;">​</a></h4><p>e.g. 1 subquery related to outer layer query</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">where</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> common_field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">where</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> s1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> s2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span></code></pre></div><p>execution sequence:</p><ol><li>get a record from outer layer query</li><li>get key3 from that record</li><li>check if where return true,if so, add it to the result set</li><li>repeat step 1~3 for each record from s1</li></ol><p>e.g. 2 subquery not related to outer layer query</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s1    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">IN</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> common_field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>once subquery return too many records, it will cause efficiency problem like:</p><ul><li>cannot use index, have to do whole table scan for outer layer</li><li>if too many params in IN(sub), a record will have to iterate each params for matching detecting. e.g. SELECT * FROM tbl_name WHERE column IN (a, b, c ..., ...); will need to check column = a OR column = b OR column = cOR ..., which will cause efficiency problem</li></ul><h5 id="materialize" tabindex="-1">Materialize <a class="header-anchor" href="#materialize" aria-label="Permalink to &quot;Materialize&quot;">​</a></h5><p>so mysql designer introduce a temp table for storing subquery result (columns from subquery).</p><ul><li>filter out duplicated values (by creating a primary index or unique index)</li><li>using hash index &amp; memory engine. hash indexes are well-suited for = but efficient for range queries memory engine use in-memory storage when you need fast, temp access to data</li></ul><p>after generated Materialize table, to find the result for</p><blockquote><p>SELECT * FROM tbl_name WHERE column IN (a, b, c ..., ...);</p></blockquote><p>is basically an inner join operation on that tmp table and s1. Optimizer will choose the lower cost way of implementation to choose which table is driving table and which one is driven table</p><h5 id="semi-join" tabindex="-1">semi-join <a class="header-anchor" href="#semi-join" aria-label="Permalink to &quot;semi-join&quot;">​</a></h5><p>internal used only. for this following sql, according to the previous section, it will be transformed as an inner join. However, if using inner join, duplicated s2 record might be added to the result set. In fact, we don&#39;t care how many matched records exist. That&#39;s where SEMI JOIN introduced</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s1    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">IN</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> common_field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>after optimizer transformed it into a semi join</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s1.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s1 SEMI </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">on</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> s1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">key1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> s2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">common_field</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;a&#39;</span></span></code></pre></div><h5 id="how-semi-join-implemented" tabindex="-1">how semi join implemented <a class="header-anchor" href="#how-semi-join-implemented" aria-label="Permalink to &quot;how semi join implemented&quot;">​</a></h5><ul><li>table pullout</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s1      </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">IN</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> key3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>since key2 is a secondary index (primary key is same) of s2, it&#39;s not containing any duplicated values. SEMI JOIN is equal to a inner join in this case. result:</p><blockquote><p>SELECT s1.* FROM s1 INNER JOIN s2 ON s1.key2 = s2.key2 WHERE s2.key3 = &#39;a&#39;;</p></blockquote><ul><li>DuplicateWeedout execution strategy</li></ul><blockquote><p>SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#39;a&#39;);</p></blockquote><p>for this query, since common_field might contain duplicated records, we introduce a temp table like this:</p><blockquote><p>CREATE TABLE tmp ( id PRIMARY KEY );</p></blockquote><p>before a record adding to the final result, we first add it to this tmp table using s1.id of that record. If adding success, we add it to the final result set, but if adding failed, we know that record has been added so we can skip this record.</p><h4 id="semi-join-constrains" tabindex="-1">semi join constrains <a class="header-anchor" href="#semi-join-constrains" aria-label="Permalink to &quot;semi join constrains&quot;">​</a></h4><p>cases that cannot apply semi join:</p><ul><li>subquery connected with outer layer quest by OR</li></ul><blockquote><p>SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = &#39;a&#39;) OR key2 &gt; 100;</p></blockquote><ul><li>NOT IN: duplicated records allowed</li></ul><blockquote><p>SELECT * FROM s1 WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = &#39;a&#39;)</p></blockquote><ul><li>subquery contains GROUP BY, HAVING, AGGREGATION, and UNION</li></ul><h4 id="convert-in-to-exists" tabindex="-1">Convert In to EXISTS <a class="header-anchor" href="#convert-in-to-exists" aria-label="Permalink to &quot;Convert In to EXISTS&quot;">​</a></h4><blockquote><p>select * from s1 where key1 in (select key3 from s2 where s1.common_field = s2.common_field) or key2 &gt; 100;</p></blockquote><p>can be converted to</p><blockquote><p>select * from s1 where exists( select 1 from s2 where s1.common_field = s2.common_field and s1.key1 = s3.key3 ) or key2 &gt; 100</p></blockquote><p>after convert, key3 index can be used in the query.</p><p>P.S. If IN(subquery) cannot be converted to semi-join, it will be tried to convert to materialized table, and if still cannot convert, it will be converted to exists.</p><p>P.S. select 1 in EXISTS() is efficient because we don&#39;t care what the select record is, we only care if there&#39;s any records in that result set. So we use select 1 here</p><h4 id="derived-table" tabindex="-1">derived table <a class="header-anchor" href="#derived-table" aria-label="Permalink to &quot;derived table&quot;">​</a></h4><blockquote><p>SELECT * FROM ( SELECT id AS d_id, key3 AS d_key3 FROM s2 WHERE key1 = &#39;a&#39; ) AS derived_s1 WHERE d_key3 = &#39;a&#39;;</p></blockquote><p>SELECT id AS d_id, key3 AS d_key3 FROM s2 WHERE key1 = &#39;a&#39; is a derived table.</p><p>For optimizing subquery with derived table, materialization is the common approach, which materialized that derived table. However, for some special case, we delay the materialization, since it may not be necessary, like the following e.g.</p><blockquote><p>SELECT * FROM ( SELECT * FROM s1 WHERE key1 = &#39;a&#39; ) AS derived_s1 INNER JOIN s2 ON derived_s1.key1 = s2.key1 WHERE s2.key2 = 1;</p></blockquote><p>Optimizer will first try to find s2.key2 = 1, if cannot find any, then materialization is meaning less.</p><p>The other approach is to rewrite the derived table into no derived table forms. e.g. the previous e.g. can be re-write as</p><blockquote><p>select * from s1 inner join s2 on s1.key1 = s2.key1 where s2.key2=1 amd s1.key1=&#39;a&#39;</p></blockquote>`,81);function q(e,w,C,F,v,D){const r=a("Badge"),h=d,p=a("ClientOnly");return l(),c("div",null,[o("h1",E,[t("How MySql Do the optimization using sql re-write "),n(r,{text:"MySQL",type:"warning"}),t(),f]),n(p,null,{default:u(()=>{var i,s;return[(((i=e.$frontmatter)==null?void 0:i.aside)??!0)&&(((s=e.$frontmatter)==null?void 0:s.showArticleMetadata)??!0)?(l(),y(h,{key:0,article:e.$frontmatter},null,8,["article"])):g("",!0)]}),_:1}),A])}const N=k(b,[["render",q]]);export{S as __pageData,N as default};
